package main

import (
	"bytes"
	"compress/gzip"
	"context"
	"crypto/tls"
	"fmt"
	"io"
	"log"
	"math/rand"
	"net"
	"net/http"
	"net/url"
	"os"
	"strconv"
	"strings"
	"sync"
	"sync/atomic"
	"time"

	utls "github.com/refraction-networking/utls"
	"golang.org/x/net/http2"
)

// ÊµèËßàÂô®ÊåáÁ∫πÈÖçÁΩÆÔºà‰∏•Ê†ºÂü∫‰∫é uTLS v1.6.0 ÊîØÊåÅÁöÑ ClientHelloIDÔºâ
type BrowserProfile struct {
	Name            string
	UserAgent       string
	SecChUa         string // Chrome/Edge Á≥ªÂàóÁâπÊúâ
	SecChUaPlatform string // Chrome/Edge Á≥ªÂàóÁâπÊúâ
	AcceptLanguage  string
	Accept          string
	ClientHello     utls.ClientHelloID
}

// Cookie ‰ºöËØùÁÆ°ÁêÜ
type CookieSession struct {
	cookies        []*http.Cookie
	lastUpdate     time.Time
	earliestExpiry time.Time   // ÊúÄÊó©ËøáÊúüÁöÑ Cookie ÁöÑËøáÊúüÊó∂Èó¥
	refreshing     atomic.Bool // ÊòØÂê¶Ê≠£Âú®Âà∑Êñ∞ÔºàÈò≤Ê≠¢Âπ∂ÂèëÂà∑Êñ∞Ôºâ
	mu             sync.RWMutex
}

// ÁªüËÆ°‰ø°ÊÅØ
type Stats struct {
	totalRequests       atomic.Int64
	successRequests     atomic.Int64
	failedRequests      atomic.Int64
	sessionRefreshCount atomic.Int64
	startTime           time.Time
	browserUsage        sync.Map // ËÆ∞ÂΩïÊØè‰∏™ÊµèËßàÂô®ÁöÑ‰ΩøÁî®Ê¨°Êï∞
}

var (
	stats           = &Stats{startTime: time.Now()}
	clientPool      sync.Pool // Êó† IPv6 ÁªëÂÆöÁöÑÂÆ¢Êà∑Á´ØÊ±†
	ipv6ClientCache sync.Map  // IPv6 Âú∞ÂùÄ -> *http.Client ÁöÑÁºìÂ≠ò
	sessionManager  sync.Map  // IPv6 Âú∞ÂùÄ -> *CookieSession ÁöÑÁºìÂ≠òÔºàÊØè‰∏™ IPv6 Áã¨Á´ã SessionÔºâ
	allowedDomains  = map[string]bool{
		"kh.google.com":    true,
		"earth.google.com": true,
		"www.google.com":   true,
	}

	// ÊµèËßàÂô®ÊåáÁ∫πÂ∫ìÔºàÂü∫‰∫é uTLS v1.8.1 ÂÆòÊñπÊîØÊåÅÔºâ
	browserProfiles = []BrowserProfile{
		// ========== Chrome Á≥ªÂàóÔºàChromium ÂÜÖÊ†∏Ôºâ==========
		{
			Name:            "Chrome 133 (Windows 11)",
			UserAgent:       "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/133.0.0.0 Safari/537.36",
			SecChUa:         `"Chromium";v="133", "Not(A:Brand";v="24", "Google Chrome";v="133"`,
			SecChUaPlatform: `"Windows"`,
			AcceptLanguage:  "zh-CN,zh;q=0.9,en;q=0.8",
			Accept:          "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7",
			ClientHello:     utls.HelloChrome_133,
		},
		{
			Name:            "Chrome 131 (Windows 10)",
			UserAgent:       "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36",
			SecChUa:         `"Google Chrome";v="131", "Chromium";v="131", "Not_A Brand";v="24"`,
			SecChUaPlatform: `"Windows"`,
			AcceptLanguage:  "zh-CN,zh;q=0.9,en;q=0.8",
			Accept:          "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7",
			ClientHello:     utls.HelloChrome_131,
		},
		{
			Name:            "Chrome 120 (Windows 10)",
			UserAgent:       "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
			SecChUa:         `"Not_A Brand";v="8", "Chromium";v="120", "Google Chrome";v="120"`,
			SecChUaPlatform: `"Windows"`,
			AcceptLanguage:  "zh-CN,zh;q=0.9,en;q=0.8",
			Accept:          "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7",
			ClientHello:     utls.HelloChrome_120,
		},
		{
			Name:            "Chrome 102 (Windows 10)",
			UserAgent:       "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/102.0.0.0 Safari/537.36",
			SecChUa:         `" Not A;Brand";v="99", "Chromium";v="102", "Google Chrome";v="102"`,
			SecChUaPlatform: `"Windows"`,
			AcceptLanguage:  "en-US,en;q=0.9",
			Accept:          "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8",
			ClientHello:     utls.HelloChrome_102,
		},
		{
			Name:            "Chrome 106 (macOS)",
			UserAgent:       "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36",
			SecChUa:         `"Chromium";v="106", "Google Chrome";v="106", "Not;A=Brand";v="99"`,
			SecChUaPlatform: `"macOS"`,
			AcceptLanguage:  "en-US,en;q=0.9",
			Accept:          "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8",
			ClientHello:     utls.HelloChrome_106_Shuffle,
		},
		{
			Name:            "Chrome 100 (Linux)",
			UserAgent:       "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.127 Safari/537.36",
			SecChUa:         `" Not A;Brand";v="99", "Chromium";v="100", "Google Chrome";v="100"`,
			SecChUaPlatform: `"Linux"`,
			AcceptLanguage:  "en-US,en;q=0.9",
			Accept:          "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8",
			ClientHello:     utls.HelloChrome_100,
		},

		// ========== Firefox Á≥ªÂàó ==========
		{
			Name:            "Firefox 120 (Windows 10)",
			UserAgent:       "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:120.0) Gecko/20100101 Firefox/120.0",
			SecChUa:         "", // Firefox ‰∏ç‰ΩøÁî® Sec-Ch-Ua
			SecChUaPlatform: "",
			AcceptLanguage:  "en-US,en;q=0.5",
			Accept:          "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8",
			ClientHello:     utls.HelloFirefox_120,
		},
		{
			Name:            "Firefox 105 (macOS)",
			UserAgent:       "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:105.0) Gecko/20100101 Firefox/105.0",
			SecChUa:         "",
			SecChUaPlatform: "",
			AcceptLanguage:  "en-US,en;q=0.5",
			Accept:          "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8",
			ClientHello:     utls.HelloFirefox_105,
		},
		{
			Name:            "Firefox 102 (Linux)",
			UserAgent:       "Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101 Firefox/102.0",
			SecChUa:         "",
			SecChUaPlatform: "",
			AcceptLanguage:  "en-US,en;q=0.5",
			Accept:          "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8",
			ClientHello:     utls.HelloFirefox_102,
		},

		// ========== Edge Á≥ªÂàó ==========
		{
			Name:            "Edge 106 (Windows 11)",
			UserAgent:       "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36 Edg/106.0.1370.52",
			SecChUa:         `"Chromium";v="106", "Microsoft Edge";v="106", "Not;A=Brand";v="99"`,
			SecChUaPlatform: `"Windows"`,
			AcceptLanguage:  "en-US,en;q=0.9",
			Accept:          "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8",
			ClientHello:     utls.HelloEdge_106,
		},
		{
			Name:            "Edge 85 (Windows 10)",
			UserAgent:       "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.102 Safari/537.36 Edg/85.0.564.51",
			SecChUa:         `"Chromium";v="85", "Microsoft Edge";v="85", ";Not A Brand";v="99"`,
			SecChUaPlatform: `"Windows"`,
			AcceptLanguage:  "en-US,en;q=0.9",
			Accept:          "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8",
			ClientHello:     utls.HelloEdge_85,
		},

		// ========== Safari Á≥ªÂàó ==========
		{
			Name:            "Safari 16.0 (macOS)",
			UserAgent:       "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.0 Safari/605.1.15",
			SecChUa:         "", // Safari ‰∏ç‰ΩøÁî® Sec-Ch-Ua
			SecChUaPlatform: "",
			AcceptLanguage:  "en-US,en;q=0.9",
			Accept:          "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
			ClientHello:     utls.HelloSafari_16_0,
		},

		// ========== iOS Safari Á≥ªÂàó ==========
		{
			Name:            "iOS 14 Safari (iPhone)",
			UserAgent:       "Mozilla/5.0 (iPhone; CPU iPhone OS 14_7_1 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.2 Mobile/15E148 Safari/604.1",
			SecChUa:         "",
			SecChUaPlatform: "",
			AcceptLanguage:  "en-US,en;q=0.9",
			Accept:          "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
			ClientHello:     utls.HelloIOS_14,
		},
		{
			Name:            "iOS 13 Safari (iPad)",
			UserAgent:       "Mozilla/5.0 (iPad; CPU OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1.2 Mobile/15E148 Safari/604.1",
			SecChUa:         "",
			SecChUaPlatform: "",
			AcceptLanguage:  "en-US,en;q=0.9",
			Accept:          "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
			ClientHello:     utls.HelloIOS_13,
		},
	}

	rng *rand.Rand // ÂÖ®Â±ÄÈöèÊú∫Êï∞ÁîüÊàêÂô®
)

// ÂàùÂßãÂåñ
func init() {
	rng = rand.New(rand.NewSource(time.Now().UnixNano()))

	clientPool = sync.Pool{
		New: func() interface{} {
			return createUTLSClient()
		},
	}

	log.Printf("üé≠ uTLS ÊµèËßàÂô®ÊåáÁ∫πÂ∫ìÂ∑≤Âä†ËΩΩ: %d ÁßçÈÖçÁΩÆÔºàÂü∫‰∫é uTLS v1.8.1Ôºâ", len(browserProfiles))
	for i, profile := range browserProfiles {
		log.Printf("  [%d] %s", i+1, profile.Name)
	}
}

// ÈöèÊú∫ÈÄâÊã©ÊµèËßàÂô®ÊåáÁ∫π
func getRandomBrowserProfile() BrowserProfile {
	index := rng.Intn(len(browserProfiles))
	profile := browserProfiles[index]

	// ÁªüËÆ°‰ΩøÁî®ÊÉÖÂÜµ
	count, _ := stats.browserUsage.LoadOrStore(profile.Name, new(atomic.Int64))
	count.(*atomic.Int64).Add(1)

	return profile
}

// ÂàõÂª∫ÂèØÂ§çÁî®ÁöÑ uTLS ÂÆ¢Êà∑Á´ØÔºà‰ΩøÁî®ÈöèÊú∫ÊµèËßàÂô®ÊåáÁ∫πÔºâ
func createUTLSClient() *http.Client {
	profile := getRandomBrowserProfile()

	transport := &http2.Transport{
		AllowHTTP:         false,
		MaxHeaderListSize: 262144,
		ReadIdleTimeout:   60 * time.Second,
		PingTimeout:       15 * time.Second,

		DialTLS: func(network, addr string, cfg *tls.Config) (net.Conn, error) {
			dialer := &net.Dialer{
				Timeout:   10 * time.Second,
				KeepAlive: 30 * time.Second,
			}

			rawConn, err := dialer.Dial("tcp", addr)
			if err != nil {
				return nil, fmt.Errorf("TCP ËøûÊé•Â§±Ë¥•: %w", err)
			}

			tlsConfig := &utls.Config{
				ServerName:         getHostFromAddr(addr),
				InsecureSkipVerify: false,
				MinVersion:         tls.VersionTLS12,
				NextProtos:         []string{"h2", "http/1.1"},
			}

			tlsConn := utls.UClient(rawConn, tlsConfig, profile.ClientHello)

			err = tlsConn.Handshake()
			if err != nil {
				rawConn.Close()
				return nil, fmt.Errorf("TLS Êè°ÊâãÂ§±Ë¥•: %w", err)
			}

			return tlsConn, nil
		},
	}

	return &http.Client{
		Timeout:   30 * time.Second,
		Transport: transport,
	}
}

// Ëé∑ÂèñÊàñÂàõÂª∫ IPv6 ÁªëÂÆöÁöÑÂÆ¢Êà∑Á´ØÔºàÂ∏¶ÁºìÂ≠òÔºâ
func getOrCreateIPv6Client(ipv6 string) (*http.Client, error) {
	// ÂÖàÊü•ÁºìÂ≠ò
	if cached, ok := ipv6ClientCache.Load(ipv6); ok {
		return cached.(*http.Client), nil
	}

	// ÁºìÂ≠òÊú™ÂëΩ‰∏≠ÔºåÂàõÂª∫Êñ∞ÂÆ¢Êà∑Á´Ø
	client, err := createUTLSClientWithIPv6(ipv6)
	if err != nil {
		return nil, err
	}

	// Â≠òÂÖ•ÁºìÂ≠ò
	ipv6ClientCache.Store(ipv6, client)
	log.Printf("‚úì ‰∏∫ IPv6 %s ÂàõÂª∫Âπ∂ÁºìÂ≠òÊñ∞ÂÆ¢Êà∑Á´Ø", ipv6[:min(20, len(ipv6))])

	return client, nil
}

// ÂàõÂª∫Â∏¶ IPv6 ÁªëÂÆöÁöÑÂÆ¢Êà∑Á´ØÔºà‰ΩøÁî®ÈöèÊú∫ÊµèËßàÂô®ÊåáÁ∫πÔºâ
func createUTLSClientWithIPv6(ipv6 string) (*http.Client, error) {
	localAddr, err := net.ResolveIPAddr("ip6", ipv6)
	if err != nil {
		return nil, fmt.Errorf("Êó†ÊïàÁöÑ IPv6 Âú∞ÂùÄ: %w", err)
	}

	profile := getRandomBrowserProfile()

	transport := &http2.Transport{
		AllowHTTP:         false,
		MaxHeaderListSize: 262144,
		ReadIdleTimeout:   60 * time.Second,
		PingTimeout:       15 * time.Second,

		DialTLS: func(network, addr string, cfg *tls.Config) (net.Conn, error) {
			dialer := &net.Dialer{
				Timeout:   10 * time.Second,
				KeepAlive: 30 * time.Second,
				LocalAddr: &net.TCPAddr{IP: localAddr.IP},
			}

			rawConn, err := dialer.Dial("tcp6", addr)
			if err != nil {
				return nil, fmt.Errorf("TCP6 ËøûÊé•Â§±Ë¥•: %w", err)
			}

			tlsConfig := &utls.Config{
				ServerName:         getHostFromAddr(addr),
				InsecureSkipVerify: false,
				MinVersion:         tls.VersionTLS12,
				NextProtos:         []string{"h2", "http/1.1"},
			}

			tlsConn := utls.UClient(rawConn, tlsConfig, profile.ClientHello)

			err = tlsConn.Handshake()
			if err != nil {
				rawConn.Close()
				return nil, fmt.Errorf("TLS Êè°ÊâãÂ§±Ë¥•: %w", err)
			}

			return tlsConn, nil
		},
	}

	return &http.Client{
		Timeout:   30 * time.Second,
		Transport: transport,
	}, nil
}

// min ËæÖÂä©ÂáΩÊï∞
func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

// ‰ªé addr (host:port) ÊèêÂèñ host
func getHostFromAddr(addr string) string {
	host, _, err := net.SplitHostPort(addr)
	if err != nil {
		return addr
	}
	return host
}

// Ëß£Âéã gzip ÂìçÂ∫î
func decompressGzip(data []byte) ([]byte, error) {
	reader, err := gzip.NewReader(bytes.NewReader(data))
	if err != nil {
		return nil, err
	}
	defer reader.Close()
	return io.ReadAll(reader)
}

// Ëé∑ÂèñÊàñÂàõÂª∫ÊåáÂÆö IPv6 ÁöÑ Session
func getOrCreateSession(ipv6 string) *CookieSession {
	// Êó† IPv6 Êó∂‰ΩøÁî®ÈªòËÆ§ SessionÔºàkey = ""Ôºâ
	if ipv6 == "" {
		ipv6 = "default"
	}

	// ÂÖàÊü•ÁºìÂ≠ò
	if cached, ok := sessionManager.Load(ipv6); ok {
		return cached.(*CookieSession)
	}

	// ÂàõÂª∫Êñ∞ Session
	session := &CookieSession{}
	sessionManager.Store(ipv6, session)
	log.Printf("‚úì ‰∏∫ IPv6 %s ÂàõÂª∫Êñ∞ Session", ipv6[:min(20, len(ipv6))])

	return session
}

// Ê£ÄÊü•ÊåáÂÆö Session ÁöÑ Cookie ÊòØÂê¶ÈúÄË¶ÅÂà∑Êñ∞
func needsRefresh(session *CookieSession) bool {
	session.mu.RLock()
	defer session.mu.RUnlock()

	// 1. Ê≤°Êúâ CookieÔºåÈúÄË¶ÅÂà∑Êñ∞
	if len(session.cookies) == 0 {
		return true
	}

	// 2. Ê£ÄÊü•ÊòØÂê¶Êúâ Cookie Â∑≤ÁªèËøáÊúüÊàñÂç≥Â∞ÜËøáÊúüÔºàÊèêÂâç 30 ÁßíÂà∑Êñ∞Ôºâ
	now := time.Now()
	if !session.earliestExpiry.IsZero() && now.Add(30*time.Second).After(session.earliestExpiry) {
		return true
	}

	// 3. ÂÖúÂ∫ïÔºöÂ¶ÇÊûú 10 ÂàÜÈíüÂÜÖÊ≤°ÊúâÂà∑Êñ∞ËøáÔºåÂº∫Âà∂Âà∑Êñ∞
	if time.Since(session.lastUpdate) > 10*time.Minute {
		return true
	}

	return false
}

// Ê∏ÖÁêÜÊåáÂÆö Session ‰∏≠Â∑≤ËøáÊúüÁöÑ Cookie
func cleanExpiredCookies(session *CookieSession) {
	session.mu.Lock()
	defer session.mu.Unlock()

	now := time.Now()
	validCookies := make([]*http.Cookie, 0, len(session.cookies))

	for _, cookie := range session.cookies {
		// Cookie Ê≤°ÊúâËÆæÁΩÆËøáÊúüÊó∂Èó¥ÔºåÊàñËÄÖËøòÊú™ËøáÊúü
		if cookie.Expires.IsZero() || cookie.Expires.After(now) {
			validCookies = append(validCookies, cookie)
		} else {
			log.Printf("üóëÔ∏è  Ê∏ÖÁêÜËøáÊúü Cookie: %s (ËøáÊúüÊó∂Èó¥: %s)",
				cookie.Name, cookie.Expires.Format(time.RFC3339))
		}
	}

	if len(validCookies) < len(session.cookies) {
		log.Printf("‚úì Cookie Ê∏ÖÁêÜÂÆåÊàêÔºö%d ‰∏™ÊúâÊïàÔºå%d ‰∏™Â∑≤ËøáÊúü",
			len(validCookies), len(session.cookies)-len(validCookies))
		session.cookies = validCookies
	}
}

// ÂàùÂßãÂåñÊàñÂà∑Êñ∞ÊåáÂÆö IPv6 ÁöÑ‰ºöËØùÔºàËÆøÈóÆ earth.google.com Ëé∑Âèñ CookieÔºâ
func refreshSession(ipv6 string, force bool) error {
	// Ëé∑ÂèñÊàñÂàõÂª∫ËØ• IPv6 ÁöÑ Session
	session := getOrCreateSession(ipv6)

	// ÂÖàÊ∏ÖÁêÜËøáÊúüÁöÑ Cookie
	cleanExpiredCookies(session)

	// Ê£ÄÊü•ÊòØÂê¶ÈúÄË¶ÅÂà∑Êñ∞
	if !force && !needsRefresh(session) {
		session.mu.RLock()
		remaining := time.Until(session.earliestExpiry).Seconds()
		session.mu.RUnlock()

		if remaining > 0 {
			log.Printf("‚úì [%s] Cookie ‰ªçÁÑ∂ÊúâÊïàÔºàÂâ©‰Ωô %.0f ÁßíÔºâ",
				ipv6[:min(20, len(ipv6))], remaining)
			return nil
		}
	}

	// ‰ΩøÁî® CAS Êìç‰ΩúÈò≤Ê≠¢Âπ∂ÂèëÂà∑Êñ∞
	if !session.refreshing.CompareAndSwap(false, true) {
		log.Printf("‚è≥ [%s] ÂÖ∂‰ªñ goroutine Ê≠£Âú®Âà∑Êñ∞‰ºöËØùÔºåÁ≠âÂæÖ...", ipv6[:min(20, len(ipv6))])
		// Á≠âÂæÖÂÖ∂‰ªñ goroutine ÂÆåÊàêÂà∑Êñ∞
		for session.refreshing.Load() {
			time.Sleep(100 * time.Millisecond)
		}
		log.Printf("‚úì [%s] ‰ºöËØùÂà∑Êñ∞ÂÆåÊàêÔºå‰ΩøÁî®Êñ∞ Cookie", ipv6[:min(20, len(ipv6))])
		return nil
	}
	defer session.refreshing.Store(false)

	log.Printf("üîÑ [%s] Âà∑Êñ∞‰ºöËØùÔºöËÆøÈóÆ earth.google.com...", ipv6[:min(20, len(ipv6))])

	// ÈöèÊú∫ÈÄâÊã©ÊµèËßàÂô®ÊåáÁ∫πÁî®‰∫é‰ºöËØùÂà∑Êñ∞
	profile := getRandomBrowserProfile()
	log.Printf("üé≠ ‰ΩøÁî®ÊµèËßàÂô®ÊåáÁ∫π: %s", profile.Name)

	var client *http.Client
	var err error
	var shouldReturn bool

	if ipv6 != "" {
		// ‰ΩøÁî®ÁºìÂ≠òËé∑Âèñ IPv6 ÂÆ¢Êà∑Á´Ø
		client, err = getOrCreateIPv6Client(ipv6)
		if err != nil {
			log.Printf("‚ö†Ô∏è  Ëé∑Âèñ IPv6 ÂÆ¢Êà∑Á´ØÂ§±Ë¥•Ôºå‰ΩøÁî®ÈªòËÆ§ÂÆ¢Êà∑Á´Ø: %v", err)
			client = clientPool.Get().(*http.Client)
			shouldReturn = true
		} else {
			shouldReturn = false
		}
	} else {
		client = clientPool.Get().(*http.Client)
		shouldReturn = true
	}

	if shouldReturn {
		defer clientPool.Put(client)
	}

	ctx, cancel := context.WithTimeout(context.Background(), 15*time.Second)
	defer cancel()

	req, err := http.NewRequestWithContext(ctx, "GET", "https://earth.google.com/web/", nil)
	if err != nil {
		return fmt.Errorf("ÂàõÂª∫‰ºöËØùËØ∑Ê±ÇÂ§±Ë¥•: %w", err)
	}

	// ‰ΩøÁî®ÈöèÊú∫ÈÄâÊã©ÁöÑÊµèËßàÂô®ÊåáÁ∫πËÆæÁΩÆ Headers
	setHeaders(req, profile, true)

	resp, err := client.Do(req)
	if err != nil {
		return fmt.Errorf("‰ºöËØùËØ∑Ê±ÇÂ§±Ë¥•: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		return fmt.Errorf("‰ºöËØùËØ∑Ê±ÇÂ§±Ë¥•: HTTP %d", resp.StatusCode)
	}

	io.Copy(io.Discard, resp.Body)

	cookies := resp.Cookies()
	if len(cookies) == 0 {
		return fmt.Errorf("Êú™Ëé∑ÂèñÂà∞ Cookie")
	}

	// ËÆ°ÁÆóÊúÄÊó©ËøáÊúüÊó∂Èó¥
	now := time.Now()
	earliestExpiry := time.Time{}

	for _, cookie := range cookies {
		// Â¶ÇÊûú Cookie Ê≤°ÊúâËÆæÁΩÆËøáÊúüÊó∂Èó¥Ôºå‰ΩøÁî® MaxAge
		if cookie.Expires.IsZero() && cookie.MaxAge > 0 {
			cookie.Expires = now.Add(time.Duration(cookie.MaxAge) * time.Second)
		}

		// ËÆ∞ÂΩïÊúÄÊó©ËøáÊúüÊó∂Èó¥ÔºàÊéíÈô§ session cookieÔºâ
		if !cookie.Expires.IsZero() {
			if earliestExpiry.IsZero() || cookie.Expires.Before(earliestExpiry) {
				earliestExpiry = cookie.Expires
			}
		}
	}

	// Â¶ÇÊûúÊâÄÊúâ Cookie ÈÉΩÊòØ session cookieÔºàÊ≤°ÊúâËøáÊúüÊó∂Èó¥ÔºâÔºåÈªòËÆ§ 1 Â∞èÊó∂ÂêéËøáÊúü
	if earliestExpiry.IsZero() {
		earliestExpiry = now.Add(1 * time.Hour)
	}

	session.mu.Lock()
	session.cookies = cookies
	session.lastUpdate = now
	session.earliestExpiry = earliestExpiry
	session.mu.Unlock()

	stats.sessionRefreshCount.Add(1)

	log.Printf("‚úì [%s] ‰ºöËØùÂ∑≤Âà∑Êñ∞ÔºåËé∑Âæó %d ‰∏™ Cookie", ipv6[:min(20, len(ipv6))], len(cookies))
	for _, cookie := range cookies {
		expiryInfo := "Session"
		if !cookie.Expires.IsZero() {
			expiryInfo = fmt.Sprintf("ËøáÊúü: %s", cookie.Expires.Format("15:04:05"))
		}
		
		// ÊòæÁ§∫ Cookie ÁöÑ DomainÔºåÁ°ÆËÆ§ÂèØ‰ª•Ë∑®Âüü‰ΩøÁî®
		domainInfo := cookie.Domain
		if domainInfo == "" {
			domainInfo = "earth.google.com"  // ÈªòËÆ§Âüü
		}
		
		log.Printf("  - %s=%s... (Domain: %s, %s)", 
			cookie.Name, safeSubstring(cookie.Value, 20), domainInfo, expiryInfo)
	}
	log.Printf("  ‚è∞ ÊúÄÊó©ËøáÊúüÊó∂Èó¥: %sÔºà%d ÁßíÂêéÔºâ", 
		earliestExpiry.Format("15:04:05"), int(time.Until(earliestExpiry).Seconds()))

	return nil
}

// ËÆæÁΩÆ HTTP HeadersÔºàÊ†πÊçÆÊµèËßàÂô®ÊåáÁ∫πÔºâ
func setHeaders(req *http.Request, profile BrowserProfile, isSessionRequest bool) {
	// Âü∫Á°Ä Headers
	req.Header.Set("User-Agent", profile.UserAgent)
	req.Header.Set("Accept-Language", profile.AcceptLanguage)

	// Chrome/Edge ÁâπÊúâÁöÑ Sec-Ch-Ua Headers
	if profile.SecChUa != "" {
		req.Header.Set("Sec-Ch-Ua", profile.SecChUa)
		req.Header.Set("Sec-Ch-Ua-Mobile", "?0")
		req.Header.Set("Sec-Ch-Ua-Platform", profile.SecChUaPlatform)
	}

	// Accept Â§¥
	if isSessionRequest {
		req.Header.Set("Accept", profile.Accept)
		req.Header.Set("Sec-Fetch-Dest", "document")
		req.Header.Set("Sec-Fetch-Mode", "navigate")
		req.Header.Set("Sec-Fetch-Site", "none")
		req.Header.Set("Sec-Fetch-User", "?1")
		req.Header.Set("Upgrade-Insecure-Requests", "1")
	} else {
		req.Header.Set("Accept", "*/*")
		req.Header.Set("Accept-Encoding", "gzip, deflate, br")
		req.Header.Set("Sec-Fetch-Dest", "empty")
		req.Header.Set("Sec-Fetch-Mode", "cors")
		req.Header.Set("Sec-Fetch-Site", "same-site")
	}

	// ÈÄöÁî® Headers
	req.Header.Set("Cache-Control", "no-cache")
	req.Header.Set("Pragma", "no-cache")

	// ÈöèÊú∫Ê∑ªÂä†‰∏Ä‰∫õÂèØÈÄâ HeadersÔºàÂ¢ûÂä†ÁúüÂÆûÊÄßÔºâ
	if rng.Float32() < 0.5 {
		req.Header.Set("DNT", "1") // Do Not Track
	}
}

// ÂÆâÂÖ®ÁöÑÂ≠óÁ¨¶‰∏≤Êà™Âèñ
func safeSubstring(s string, length int) string {
	if len(s) <= length {
		return s
	}
	return s[:length]
}

// Ê£ÄÊü• Cookie ÊòØÂê¶ÈÄÇÁî®‰∫éÁõÆÊ†áÂüüÂêç
func cookieMatchesDomain(cookie *http.Cookie, targetDomain string) bool {
	// Â¶ÇÊûú Cookie Ê≤°ÊúâËÆæÁΩÆ DomainÔºåÂàôÂè™ÈÄÇÁî®‰∫éËÆæÁΩÆÂÆÉÁöÑÂüüÂêç
	if cookie.Domain == "" {
		return false
	}
	
	// Cookie Domain ‰ª• . ÂºÄÂ§¥Ë°®Á§∫ÈÄÇÁî®‰∫éÊâÄÊúâÂ≠êÂüüÂêç
	// ‰æãÂ¶Ç .google.com ÈÄÇÁî®‰∫é kh.google.com, earth.google.com Á≠â
	if strings.HasPrefix(cookie.Domain, ".") {
		return strings.HasSuffix(targetDomain, cookie.Domain) || 
		       targetDomain == strings.TrimPrefix(cookie.Domain, ".")
	}
	
	// ÂÆåÂÖ®ÂåπÈÖç
	return cookie.Domain == targetDomain
}

// ËøáÊª§ÈÄÇÁî®‰∫éÁõÆÊ†áÂüüÂêçÁöÑ Cookie
func filterCookiesForDomain(cookies []*http.Cookie, targetDomain string) []*http.Cookie {
	validCookies := make([]*http.Cookie, 0, len(cookies))
	
	for _, cookie := range cookies {
		if cookieMatchesDomain(cookie, targetDomain) {
			validCookies = append(validCookies, cookie)
		}
	}
	
	return validCookies
}

// È™åËØÅ URL ÊòØÂê¶ÂÖÅËÆ∏ËÆøÈóÆ
func isAllowedURL(targetURL string) error {
	parsedURL, err := url.Parse(targetURL)
	if err != nil {
		return fmt.Errorf("Êó†ÊïàÁöÑ URL: %w", err)
	}

	if parsedURL.Scheme != "https" {
		return fmt.Errorf("Âè™ÂÖÅËÆ∏ HTTPS ÂçèËÆÆ")
	}

	if !allowedDomains[parsedURL.Host] {
		return fmt.Errorf("ÂüüÂêç‰∏çÂú®ÁôΩÂêçÂçï‰∏≠: %s", parsedURL.Host)
	}

	return nil
}

// HTTP ‰ª£ÁêÜÂ§ÑÁêÜÂô®
func proxyHandler(w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	stats.totalRequests.Add(1)

	targetURL := r.URL.Query().Get("url")
	ipv6 := r.URL.Query().Get("ipv6")

	if targetURL == "" {
		http.Error(w, "Missing 'url' parameter", http.StatusBadRequest)
		return
	}

	// È™åËØÅ URL
	if err := isAllowedURL(targetURL); err != nil {
		log.Printf("‚ùå URL È™åËØÅÂ§±Ë¥•: %v", err)
		http.Error(w, "Invalid URL", http.StatusBadRequest)
		stats.failedRequests.Add(1)
		return
	}

	// È™åËØÅ IPv6 Âú∞ÂùÄ
	if ipv6 != "" {
		if _, err := net.ResolveIPAddr("ip6", ipv6); err != nil {
			log.Printf("‚ùå Êó†ÊïàÁöÑ IPv6 Âú∞ÂùÄ: %s", ipv6)
			http.Error(w, "Invalid IPv6 address", http.StatusBadRequest)
			stats.failedRequests.Add(1)
			return
		}
	}

	// ÈöèÊú∫ÈÄâÊã©ÊµèËßàÂô®ÊåáÁ∫π
	profile := getRandomBrowserProfile()

	// Ëé∑ÂèñÂÆ¢Êà∑Á´ØÔºà‰ºòÂÖà‰ªéÁºìÂ≠òËé∑ÂèñÔºâ
	var client *http.Client

	if ipv6 != "" {
		// Êúâ IPv6Ôºö‰ªéÁºìÂ≠òËé∑ÂèñÊàñÂàõÂª∫Ôºà‰ºöËá™Âä®ÁºìÂ≠òÔºâ
		var err error
		client, err = getOrCreateIPv6Client(ipv6)
		if err != nil {
			log.Printf("‚ùå Ëé∑Âèñ IPv6 ÂÆ¢Êà∑Á´ØÂ§±Ë¥•: %v", err)
			http.Error(w, "IPv6 client creation failed", http.StatusInternalServerError)
			stats.failedRequests.Add(1)
			return
		}
	} else {
		// Êó† IPv6Ôºö‰ΩøÁî®ÈÄöÁî®ËøûÊé•Ê±†
		client = clientPool.Get().(*http.Client)
		defer clientPool.Put(client)
	}

	// Âà∑Êñ∞‰ºöËØùÔºàÈíàÂØπ kh.google.comÔºâ
	parsedURL, _ := url.Parse(targetURL)
	needsSession := parsedURL.Host == "kh.google.com"

	if needsSession {
		for attempt := 1; attempt <= 3; attempt++ {
			if err := refreshSession(ipv6, false); err != nil {
				log.Printf("‚ö†Ô∏è  ‰ºöËØùÂà∑Êñ∞Â§±Ë¥•ÔºàÂ∞ùËØï %d/3Ôºâ: %v", attempt, err)
				if attempt < 3 {
					time.Sleep(time.Duration(attempt) * time.Second)
					continue
				}
				log.Printf("‚ö†Ô∏è  ‰ºöËØùÂà∑Êñ∞ËøûÁª≠Â§±Ë¥•Ôºå‰ΩøÁî®Êóß Cookie")
			}
			break
		}
	}

	// ÂàõÂª∫ËØ∑Ê±Ç
	ctx, cancel := context.WithTimeout(context.Background(), 25*time.Second)
	defer cancel()

	req, err := http.NewRequestWithContext(ctx, "GET", targetURL, nil)
	if err != nil {
		log.Printf("‚ùå ÂàõÂª∫ËØ∑Ê±ÇÂ§±Ë¥•: %v", err)
		http.Error(w, "Request creation failed", http.StatusInternalServerError)
		stats.failedRequests.Add(1)
		return
	}

	// ‰ΩøÁî®ÈöèÊú∫ÊµèËßàÂô®ÊåáÁ∫πËÆæÁΩÆ Headers
	setHeaders(req, profile, false)

	// ÂÖ≥ÈîÆÔºöÂøÖÈ°ªÊúâ Referer Âíå Origin
	if !strings.Contains(targetURL, "www.google.com") {
		req.Header.Set("Referer", "https://earth.google.com/")
		req.Header.Set("Origin", "https://earth.google.com")
	}

	// Ëé∑ÂèñËØ• IPv6 ÁöÑ Session Âπ∂Ê∑ªÂä† Cookie
	session := getOrCreateSession(ipv6)
	session.mu.RLock()
	for _, cookie := range session.cookies {
		req.AddCookie(cookie)
	}
	session.mu.RUnlock()

	// ÂèëÈÄÅËØ∑Ê±ÇÔºàÊîØÊåÅ 403 Ëá™Âä®ÈáçËØïÔºâ
	var resp *http.Response
	maxRetries := 1 // 403 Êó∂ÊúÄÂ§öÈáçËØï 1 Ê¨°

	for attempt := 0; attempt <= maxRetries; attempt++ {
		resp, err = client.Do(req)
		if err != nil {
			log.Printf("‚ùå ËØ∑Ê±ÇÂ§±Ë¥•: %v", err)
			http.Error(w, "Request failed", http.StatusBadGateway)
			stats.failedRequests.Add(1)
			return
		}

		// Â¶ÇÊûúÊòØ 403 ‰∏îÊòØÁ¨¨‰∏ÄÊ¨°Â∞ùËØïÔºåÁ´ãÂç≥Âà∑Êñ∞ Cookie Âπ∂ÈáçËØï
		if resp.StatusCode == 403 && attempt == 0 && needsSession {
			log.Printf("‚ö†Ô∏è  Êî∂Âà∞ 403ÔºåCookie ÂèØËÉΩÂ§±ÊïàÔºåÁ´ãÂç≥Âà∑Êñ∞Âπ∂ÈáçËØï...")
			resp.Body.Close()

			// Âº∫Âà∂Âà∑Êñ∞ Session
			if err := refreshSession(ipv6, true); err != nil {
				log.Printf("‚ùå Âº∫Âà∂Âà∑Êñ∞‰ºöËØùÂ§±Ë¥•: %v", err)
				http.Error(w, "Session refresh failed", http.StatusServiceUnavailable)
				stats.failedRequests.Add(1)
				return
			}

			// ÈáçÊñ∞ÂàõÂª∫ËØ∑Ê±ÇÔºàÈúÄË¶ÅÈáçÊñ∞Ê∑ªÂä† CookieÔºâ
			req, _ = http.NewRequestWithContext(ctx, "GET", targetURL, nil)
			setHeaders(req, profile, false)
			if !strings.Contains(targetURL, "www.google.com") {
				req.Header.Set("Referer", "https://earth.google.com/")
				req.Header.Set("Origin", "https://earth.google.com")
			}

			// Ê∑ªÂä†Êñ∞Âà∑Êñ∞ÁöÑ Cookie
			session.mu.RLock()
			for _, cookie := range session.cookies {
				req.AddCookie(cookie)
			}
			session.mu.RUnlock()

			log.Printf("üîÑ ‰ΩøÁî®Êñ∞ Cookie ÈáçËØïËØ∑Ê±Ç...")
			continue // ÈáçËØï
		}

		// ÊàêÂäüÊàñÈùû 403 ÈîôËØØÔºåË∑≥Âá∫Âæ™ÁéØ
		break
	}
	defer resp.Body.Close()

	// ËØªÂèñÂìçÂ∫î‰Ωì
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		log.Printf("‚ùå ËØªÂèñÂìçÂ∫îÂ§±Ë¥•: %v", err)
		http.Error(w, "Failed to read response", http.StatusInternalServerError)
		stats.failedRequests.Add(1)
		return
	}

	// Ëß£Âéã gzip
	if resp.Header.Get("Content-Encoding") == "gzip" {
		body, err = decompressGzip(body)
		if err != nil {
			log.Printf("‚ùå Ëß£ÂéãÂ§±Ë¥•: %v", err)
			http.Error(w, "Failed to decompress response", http.StatusInternalServerError)
			stats.failedRequests.Add(1)
			return
		}
	}

	duration := time.Since(startTime)
	stats.successRequests.Add(1)

	ipv6Display := safeSubstring(ipv6, 20)
	if ipv6Display == "" {
		ipv6Display = "default"
	}
	urlDisplay := safeSubstring(targetURL, 60)

	log.Printf("‚úÖ [%s] [%s] %d - %s (%dms, %d bytes)",
		ipv6Display, profile.Name, resp.StatusCode, urlDisplay,
		duration.Milliseconds(), len(body))

	// ËøîÂõûÂìçÂ∫î
	w.Header().Set("Content-Type", "application/octet-stream")
	w.Header().Set("X-Status-Code", strconv.Itoa(resp.StatusCode))
	w.Header().Set("X-Duration-Ms", strconv.FormatInt(duration.Milliseconds(), 10))
	w.Header().Set("X-Browser-Profile", profile.Name)

	for key, values := range resp.Header {
		for _, value := range values {
			w.Header().Add("X-Origin-"+key, value)
		}
	}

	w.WriteHeader(http.StatusOK)
	w.Write(body)
}

// ÂÅ•Â∫∑Ê£ÄÊü•Â§ÑÁêÜÂô®
func healthHandler(w http.ResponseWriter, r *http.Request) {
	uptime := time.Since(stats.startTime)
	total := stats.totalRequests.Load()
	success := stats.successRequests.Load()
	failed := stats.failedRequests.Load()
	sessionRefresh := stats.sessionRefreshCount.Load()

	var successRate float64
	if total > 0 {
		successRate = float64(success) / float64(total) * 100
	}

	// ÁªüËÆ°ÊâÄÊúâ Session ÁöÑ‰ø°ÊÅØ
	var totalCookies int64
	var totalSessions int64
	var oldestRefresh time.Time
	var earliestExpiry time.Time

	sessionManager.Range(func(key, value interface{}) bool {
		session := value.(*CookieSession)
		session.mu.RLock()
		totalCookies += int64(len(session.cookies))

		// ËÆ∞ÂΩïÊúÄÊóßÁöÑÂà∑Êñ∞Êó∂Èó¥
		if oldestRefresh.IsZero() || session.lastUpdate.Before(oldestRefresh) {
			oldestRefresh = session.lastUpdate
		}

		// ËÆ∞ÂΩïÊúÄÊó©ÁöÑËøáÊúüÊó∂Èó¥
		if !session.earliestExpiry.IsZero() {
			if earliestExpiry.IsZero() || session.earliestExpiry.Before(earliestExpiry) {
				earliestExpiry = session.earliestExpiry
			}
		}
		session.mu.RUnlock()

		totalSessions++
		return true
	})

	// ËÆ°ÁÆó Cookie Ââ©‰ΩôÊúâÊïàÊó∂Èó¥
	var cookieValidSeconds int64
	if !earliestExpiry.IsZero() {
		remaining := time.Until(earliestExpiry).Seconds()
		if remaining > 0 {
			cookieValidSeconds = int64(remaining)
		}
	}

	// ÁªüËÆ°ÊµèËßàÂô®‰ΩøÁî®ÊÉÖÂÜµ
	browserUsage := make(map[string]int64)
	stats.browserUsage.Range(func(key, value interface{}) bool {
		browserUsage[key.(string)] = value.(*atomic.Int64).Load()
		return true
	})

	// ÁªüËÆ° IPv6 ÂÆ¢Êà∑Á´ØÁºìÂ≠òÊï∞Èáè
	var ipv6ClientCount int64
	ipv6ClientCache.Range(func(key, value interface{}) bool {
		ipv6ClientCount++
		return true
	})

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)

	// ÊûÑÂª∫ÊµèËßàÂô®‰ΩøÁî®ÁªüËÆ°
	browserStats := "{"
	first := true
	for name, count := range browserUsage {
		if !first {
			browserStats += ", "
		}
		browserStats += fmt.Sprintf(`"%s": %d`, name, count)
		first = false
	}
	browserStats += "}"

	fmt.Fprintf(w, `{
	"status": "ok",
	"uptime": %.0f,
	"totalRequests": %d,
	"successRequests": %d,
	"failedRequests": %d,
	"successRate": "%.2f%%",
	"session": {
		"totalSessions": %d,
		"totalCookies": %d,
		"oldestRefresh": "%s",
		"earliestExpiry": "%s",
		"cookieValidSeconds": %d,
		"sessionRefreshCount": %d
	},
	"clientPool": {
		"ipv6ClientsCached": %d
	},
	"browserProfiles": {
		"available": %d,
		"usage": %s
	}
}`,
		uptime.Seconds(),
		total,
		success,
		failed,
		successRate,
		totalSessions,
		totalCookies,
		oldestRefresh.Format(time.RFC3339),
		earliestExpiry.Format(time.RFC3339),
		cookieValidSeconds,
		sessionRefresh,
		ipv6ClientCount,
		len(browserProfiles),
		browserStats,
	)
}

func main() {
	port := os.Getenv("UTLS_PROXY_PORT")
	if port == "" {
		port = "8765"
	}

	http.HandleFunc("/proxy", proxyHandler)
	http.HandleFunc("/health", healthHandler)

	log.Printf("üöÄ uTLS Proxy Server starting on :%s", port)
	log.Printf("üì¶ uTLS ÁâàÊú¨: v1.8.1 (github.com/refraction-networking/utls)")
	log.Printf("üé≠ ÊµèËßàÂô®ÊåáÁ∫πÂ∫ì: %d ÁßçÂÆòÊñπÊîØÊåÅÁöÑÈÖçÁΩÆ", len(browserProfiles))
	log.Printf("üåê ‰ª£ÁêÜÁ´ØÁÇπ: http://localhost:%s/proxy?url=<URL>&ipv6=<IPv6>", port)
	log.Printf("üíö ÂÅ•Â∫∑Ê£ÄÊü•: http://localhost:%s/health", port)

	if err := http.ListenAndServe(":"+port, nil); err != nil {
		log.Fatalf("‚ùå Server failed: %v", err)
	}
}
